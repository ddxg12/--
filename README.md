# 202130235 최한솔  
# 2025.05.15 11주차
### step3의 데이터들을 다시 한번 순서대로 살펴보기  
- 제품의 원본 목록은 props로 전달되었기 때문에 state가 아님.  
- 사용자가 입력한 검색어는 시간이 지남에 따라 변하고, 다른 요소로부터 계산될 수 없기 때문에 state로 볼 수 있음  
- 체크박스의 값은 시간에 따라 바뀌고 다른 요소로부터 계산될 수 없기 때문에 state로 볼 수 있음.  
- 필터링된 제품 목록은 원본 제품 목록을 받아서 검색어와 체크박스의 값에 따라 계산할 수 있으므로 state가 아님.  
- 따라서, 검색어와 체크박스의 값만이 state임. 
### step4 state가 어디에 있어야 될 지 정하기  
- 이제 앱에서 최소한의 필요한 state를 결정했기 때문에 다음으로는 어떤 컴포넌트가 이 state를 소유하고, 변경할 책임을 지게 할 지 정해야 함  
- react는 항상 컴포넌트 계층구조를 따라 부모에서 자식으로 데이터를 전달하는 단방향 데이터 흐름을 사용한다는 것을 기억해야함  
- 앱을 구현하면서 어떤 컴포넌트가 state를 가져야 하는 지 바로 명확하지 않을 수 있음  
- 이 개념이 처음이 아니어서 어렵다면 다음과 같은 과정을 따라보자  
    - 1. 해당 state를 기반으로 렌더링하는 모든 컴포넌트를 찾음  
    - 2. 그들의 가장 가까운 공통되는 부모 컴포넌트를 찾음 - 계층에서 모두를 포괄하는 상위 컴포넌트  
    - 3. state가 어디에 위치 돼야 하는지 결정   
- state가 어디에 위치 돼야 하는지 결정하려면,  
    - 1. 대게, 공통 부모에 state를 그냥 두면 됨
    - 2. 혹은, 공통 부모 상위의 컴포넌트에 둬도 됨  
    - 3. state를 소유할 적절한 컴포넌트를 찾지 못했다면, state를 소유하는 컴포넌트를 하나 만들어서 상위 계층에 추가  
- 1. state를 쓰는 컴포넌트 찾기  
    - producttable은 state에 기반한 상품 리스트를 필터링 해야 함  
    - SearchBar는 state를 표시해 주어야 함  
- 2. 공통 부모 찾기  
    - 둘 모두가 공유하는 첫 번째 부모는 FilterableProductTable임  
- 3. 어디에 state가 존재하야 할지 정하기  
    - 우리는 FilterableProductTable에 검색어와 체크 박스 값을 state로 둠  
    - state값은 filterableproductTable 안에 있음.  
- productTable의 props를 추가해 줌 -> products, filterText, inStockOnly  
- productTable의 forEach문을 수정함  
    - 첫 번째 코드와 비교해 보면서 어디가 수정되었는지 정확하게 수정해줘야 함  
# 2025.05.08 9주차  
### React로 사고하기  
- react를 사용하게 되면 우리가 고려하고 있는 디자인이나 만들 앱들에 대한 생각을 바꿀 수 있습니다.  
- react로 사용자 인터페이스를 빌드할 때, 먼저 이를 컴포넌트라는 조각으로 나눕니다.  
- 그리고 각 컴포넌트의 다양한 시각적 상태들을 정의합니다.  
- 마지막으로 컴포넌트들을 연결하여 데이터가 그 사이를 흘러가게 합니다.  
- react는 component 기반으로 개발.  
### step1.  
- 모든 컴포넌트와 하위 컴포넌트 주변에 박스를 그리고, 그들에게 이름을 붙이면서 시작  
- 디자이너와 함께 일한다면 그들이 이미 디자인 툴을 통하여 이 컴포넌트들에 이름을 정해 두었을 수 있음  
- 어떤 배경을 가지고 있냐에 따라, 디자인을 컴포넌트로 나누는 방법에 대한 관점이 달라질 수 있음.  
- programming : 새로운 함수나 객체를 만드는 방식과 같은 방법  
    - 이 중 단일책임 원칙을 반영하고자 한다면 컴포넌트는 이상적으로는 한번에 한가지 일만 가능.  
    - 만약 컴포넌트가 점점 커진다면 작은 하위 컴포넌트로 쪼갬  
- 1.FilterableProductTable(회색): 예시 전체를 포괄합니다.  
- 2.SearchBar(파란색) : 사용자의 입력을 받습니다.  
- 3.ProductTable(라벤더색) : 데이터리스트를 보여주고, 사용자의 입력을 기반으로 필터링  
- 4.productCategoryRow(초록색) : 각 카테고리의 헤더를 보여줍니다.  
- 5.productRow(노란색): 각각의 제품에 해당하는 행을 보여줍니다.   
- productTable을 보면 name과 price 레이블을 포함한 테이블 헤더 기능만을 가진 컴포넌트는 없음  
- 독립된 컴포넌트를 따로 생성할 지 생성하지 않을지는 선택  
### step2 React로 정적인 버전 구현하기  
- 이제 컴포넌트 계층구조가 만들어졌으니 앱 구현 단계  
- 가장 쉬운 접근방법은 상호작용 기능은 아직 추가하지 않고, 데이터 모델로부터 UI를 렌더링하는 버전을 만드는 것  
- 대체로 먼저 정적인 버전을 만들고 상호작용 기능을 추가하는게 쉬움   
- 정적 버전을 만드는 것은 많은 타이핑이 필요하지만, 생각할 것은 적음  
- 반대로 상호작용 기능을 추가하는 것은 많은 생각이 필요하지만, 타이핑은 그리 많이 필요하지 않음  
- 데이터 모델을 렌더링하는 앱의 정적인 버전을 만들기 위해서는 다른 컴포넌트를 재사용하고, PROPS를 이용하여 데이터를 넘겨주는 컴포넌트를 구현하는것이 좋음  
- PROPS는 부모가 자식에게 데이터를 넘겨줄 때 사용할 수 있는 방법임.  
- state는 오직 상호작용을 위해, 즉 시간이 지남에 따라 데이터가 바뀌는것에 사용  
- 우리는 앱의 정적버전을 만들고 있기 때문에 지금은 필요하지 않음.  
- 앱을 만들때 계층 구조에 따라 상층부에 있는 컴포넌트 즉,1.FilterableProductTable부터 시작하는 하향식(top-down)으로 만드는 방법이 있음.  
- 또는 하층부에 있는 컴포넌트인 5.productRow부터 상향식(bottup-up)으로 만들수도 있음.  
- 보통 하향식으로 만드는게 쉽지만 프로젝트가 커지면 상향식으로 만들고 테스트를 작성하면서 개발하기가 더쉬움.  
- 이 단계가 끝나면 데이터 렌더링을 위해 만들어진 재사용 가능한 component들의 라이브러리를 가지게 됨  
- 현재는 앱의 정적버전이기 때문에 component는 단순히 JSX만 리턴함  
- 계층구조의 최상위 component는 prop으로 데이터 모델을 받음  
- 이는 데이터가 최상위 component부터 트리의 맨 아래까지 흘러가기 때문에 단방향 데이터 흐름이라고 부름  
### step3 최소한의 데이터만 이용해서 완벽하게 UI STATE 표현하기  
- ui를 상호작용하게 만들려면, 사용자가 기반 데이터 모델을 변경할 수 있게 해야함.  
- react는 state를 통해 기반 데이터 모델을 변경할 수 있게 함.  
- state는 앱이 기억해야 하는, 변경할 수 있는 데이터의 최소 집합이라고 생각.  
- state를 구조화 하는데 가장 중요한 원칙은 중복배제원칙(Don't Repeat Yourself)임.  
- 애플리케이션이 필요로 하는 가장 최소한의 state를 파악하고, 나머지 모든 것들은 필요에 따라 실시간으로 계산  
- 예를 들어, 쇼핑 리스트를 만든다고 하면 배열ㄹ에 상품 아이템들을 넣음  
- UI에 상품 아이템의 개수를 노출하고 싶다면, 상품아이템 개수를 따로 STATE값으로 가지는게 아니라 단순하게 배열의 길이만 쓰면 됨.

# 2025.04.17 6주차  
### closure의 개념  
- 클로저의 핵심은 스코프를 이용하여 변수의 접근 범위를 "폐쇄" 하는 것에 있습니다.  
- 외부 함수스코프에서 내부 함수 스코프로 접근이 불가능함.  
- 내부 함수에서는 외부 함수스코프에 선언된 변수에 접근이 가능  
- 장점 :  
    - 전역변수 사용 최소화  
    - 데이터 보존가능 
    - 모듈화를 통한 코드 재사용 편리   
    - 정보의 접근 제한    
### 불변성이 중요한 이유  
- 불변성을 사용하면 복잡한 기능을 훨씬 쉽게 구현할 수 있음.  
- 기본적으로 부모 컴포넌트의 state가 변경되면 모든 자식 컴포넌트가 자동으로 다시 렌더링 됨   
- 변경사항이 없는 자식 컴포넌트도 포함되어짐  
- 리렌더링 자체가 사용자에게 보이는 것은 아니지만, 성능상의 이유로 트리의 영향을 받지 않는 부분의 리렌더링을 피하는 것이 좋음  
- 불변성을 사용하면 컴포넌트가 데이터의 변경 여부를 저렴한 비용으로 판단 할 수 있음  
### 교대로 두기 -1  
- 첫번째 선수는 두는 말을 "x"로 설정. 이제 board 컴포넌트에 또 다른 state를 추가하여 추적  
- x와 y가 번갈아 한번 씩 두어야 하기 때문에 x가 두었는지 아닌지 현재의 상태를 보관하면 됨. 즉, x의 차례면 true. 0의 차례면 false 상태를 기억  
- 플레이어가 움직일 때마다 다음 플레이어를 결정하기 위해 불리언 값인 xIsNext가 반전되고 게임의 state가 저장됨. board의 handclick 함수를 업데이트하여 xIsNext의 값을 반전  
### return의 의미  
- 작성한 코드에는 return값이 없다.  
- javascript에서 return값이 없는 return:은 함수를 즉시 종료하라는 의미  
- 이때 값을 반환하지 않으면 자동으로 undefined를 반환  
- squares[i]가 이미 값이 있다면 , 그 자리에 다시 둘 수 없으니 아무 일도 하지말고 함수를 끝내는 것    
### 승자 결정하기  
- 먼저 승리할 수 있는 경우의 자리를 2차원 배열로 선언  
- 선언된 배열 line과 

### STATE 끌어올리기  
- handleClick 함수는 JAVASCRIPT의 slice() 배열 메서드를 사용하여 squarese 배열의 사본인 nextSquares를 생성함.  
- 그 다음 andleClick 함수는 nextSquares 배열의 첫 번째 squares(index [0])에 x를 추가하여 업데이트함.  
- setSquares 함수를 호출하면 react는 컴포넌트의 state가 변경되었음을 알 수 있음  
- 그러면 squares의 state를 사용하는 컴포넌트와 그 하위 컴포넌트가 다시 렌더링 됨  

- javascript는 클로저를 지원하기 때문ㅇ네 내부 함수가 외부 함수에 정의된 변수 및 함수에 접근할 수 있음  
- handclick함수는 squares의 state를 읽고 setsquares 메서드를 호출할 수 있는데, 이 두 함수는 board 함수 내부에 정의되어 있기 때문임.  

- 이제 BOARD가 모든 STATE를 관리하므로 부모 BOARD 컴포넌트는 자식 SQUARE 컴포넌트가 올바르게 표시될 수 있도록 PROPS를 전달  
- SQUARE를 클ㄹ릭하면 자식 SQUARE 컴포넌트가 부모 BOARD 컴포넌트에 BOARD의 STATE를 업데이트 하도록 요청함.  
- BOARD의 STATE가 변경되면 BOARD 컴포넌트와 모든 자식 SQUARE 컴포넌트가 자동으로 다시 렌더링 됨 
- BOARD 컴포넌트에 속한 모든 SQUARE의 STATE를 유지하면 나중에 승자 결정 가능    


# 2025.04.03 4주차  
### 이벤트에 응답하기  
- component 내부에 event handler 함수를 선언하면 event에 응답할 수 있음.  
### 화면 업데이트 하기  
- component가 특정 정보를 '기억'해 두었다가 표시하기를 원하는 경우가 있을 때 예를 들어 버튼이 클릭된 회수를 세고 싶다면 component에 state를 추가하면 됨  
- 먼저 react에서 useState를 import하고 component 내부에 state 변수를 선언  
- 실습 =  
    - 버튼이 처음 표시될 때는 useState()에 0을 전달해서 count가 0이 되도록 함  
    - state를 변경하고 싶다면 setCount()를 실행하고 새 값을 전달  
    - 버튼에서 event handler를 호출하여 setcount() 함수를 실행  
    - 버튼을 클릭하면 카운터가 증가  

- 문서의 코드는 component안에 2개의 버튼을 반환하도록 하였으나 불필요하게  복잡.  
- 우리는 useState에 집중할 수 있게 버튼하나만 반환하도록 수정   
### Hook 사용하기  
- use로 시작하는 함수를 HOOK라고 합니다.  
- useState는 react에서 제공하는 내장 HOOK입니다. 
- 다른 내장 HOOK은 api 참고서에서 찾아볼 수 있습니다.  
- 또한 기존의 것들을 조합하여 자신만의 hook를 작성할 수 있습니다. 사용자 hook  
- 다른 함수보다 제한적  
    - 예를 들면 component 또는 다른 hook의 상단에서만 hook를 호출할 수 있음  
    - 조건이나 반복문에서 useState를 사용하고 싶다면 새 컴포넌트를 추출하여 그곳에 넣음  
### Hook의 사용 규칙(Rules of Hooks)  
- hook은 react의 렌더링 및 상태 관리 메커니즘과 밀접하게 연결되어 있으며,아래와같은 규칙을 따라야 함  
    - 최상위에서만 호출해야함 
    - if,for,while등의 블록 내부에서 hooks를 호출하면 안됨  
    - 함수의 조건문 내부에서 호출하면 실행 순서가 달라질 수 있음.  
- hook의 사용규칙에는 제한이 필요한데 제한이 필요한 이유  
    - rendering 순서를 보장하기 위해서  
### function형 컴포넌트에서만 hook을 사용하는 이유?  
- class형 컴포넌트는 라이프사이클함수를 통해서 상태 관리를 했었음  
- 그런 이유 때문에 class형 컴포넌트는 유지보수가 어렵고 복잡해질 수 있었음.  
- react 는 컴포넌트의 상태관리와 로직을 더 간결하게 만들기 위해 hooks를 도입  
- 따라서 react 팀은 function형 컴포넌트를 권장  
- hook는 function형 컴포넌트 전용으로 설계    
### 컴포넌트 간 데이터 공유  
- 사이트에서는 mybutton으로 설명하고 있지만, 우리는 countstate로 작성했던 것을 기억하고 사이트의 설명을 봐야함  
- 각각의 countstate component는 독립적인 count가 있는 것 처럼 동작했고,  각 버튼을 클릭하면 클릭한 버튼의 count만 변경되었음.  
- 그러나 이 것은 이상한 것이 아니며, 각 component 객체가 독립적으로 동작하기 때문임.  
- component는 하나지만 count 변수도 객체로 여러 개 복사된 것이나 마찬가지이기 때문임.    
                                                    
# 2025.03.27 3주차 

### 데이터 표시하기  
- JSX를 사용하면 자바스크립트에 마크업을 넣을 수 있음  - JSX 코드 내에서 JAVASCRIPT로 '탈출'하여 변수나 표현식을 사용하는 것  
- 이 방법을 'ESCAPE BACK' 이라고 함  
- {} 중괄호를 사용해서 변수나 표현식을 사용자에게 표시하도록 하는 것  
- SCR 속성에 변수의 값을 전달하여 이미지의 경로설정 가능   

### 스타일 추가하기  
- react 에서는 className으로 css클래스를 지정합니다.  
- className은 HTML의 class속성과 동일한 방식으로 동작  
- css규칙은 별도의 css 파일에 작성. 그러나 css파일을 추가하는 방법을 규정하지는 않음.  
- 가장간단한 방법은 html에 링크 태그를 추가하는 것  

### JSX로 마크업 작성하기  
- 앞에서 작성한 코드의 마크업 문법을 JSX라고 함  
- 반드시 사용해야 하는 것은 아니지만, REACT프로젝트에서는 편의성을 위해 JSX를 사용함.  
- JSX는 HTML보다 더욱 엄격한 문법을 적용  
- JSX에서는 싱글 태그라도 태그를 닫아야함  
- react에서는 여러 개의 component를 jsx 태그로 반환 할 수 있음  
- 다만 여러 개의 component를 wrapping 해주어야 함

### react 실행을 위한 코드작성    
####  Buttonlib.js
- function Button1() {
    return (
        <button>Button1</button>
    )
}
function Button2() {
    return (
        <button>Button2</button>
    )
}
function Button3() {
    return (
        <button>Button3</button>
    )
}

export { Button1, Button2, Button3}

### component의 생성 및 nesting(중첩)  
- 고유한 로직과 모양을 가진 ui의 일부  
- 버튼처럼 작을 수도 있고, 전체 페이지처럼 클 수도 있음  
- 마크업을 반환하는 javascript의 함수  

- nesting은 css선택자의 중첩 구조를 생각하면 쉽게 이해할 수 있음.  

### export default and export 차이   
- Named Exports (export)  
    - 하나의 파일 안에 여러 개의 component가 있을 때 사용.  
    - component 를 사용하는 쪽에서는 component 정확한 이름 반드시 명시  
    - (ex) import ( add, subtract, multiply, divide) from'./math/  
- Default Exports  
    - 하나의 파일 안에서 하나의 component 만 내보내는 경우 사용  
    - component를 사용하는 쪽에서는 어떤 이름을 사용해도 상관없음  

# 2025.03.20 2주차  

### react  
- react에서 제일 중요한 단어 component  

### 의존성 관리와 package.json  
- 의존성을 관리하는 이유  
    - 손쉬운 설치 및 업데이트  
        - npm install 또는 yarn install 한 줄로 모든 의존성을 자동 설치 가능  
        - 특정 버전의 라이브러리를 쉽게 업데이트 가능  
    - 일관된 개발 환경 유지  
        - 팀원들과 같은 라이브러리 버전을 유지할 수 있음  
        - package-lock.json을 활용하면 동일한 패키지를 정확한 버전으로 설치가능.  
    - 중복 설치 방지  
        - 필요 없는 라이브러리를 제거하여 프로젝트를 가볍게 유지할 수 있음  

- package.json은 이런 의존성을 체계적으로 관리하는 역할  
- 프로젝트에 필요한 라이브러리를 쉽게 설치, 업데이트, 유지 할 수 있도록 도와주는 시스템  
### React Project의 구조 및 역할 tes 
- node_modules/  
- public/ : 정적(static) 파일을 저장하는 폴더로, 빌드 시 그대로 유지됨.  
    - favicon.ko : 라우저 탭에 표시되는 아이콘  
    - index.html : React 앱이 마운트되는  HTML 파일 <$div.id="root"><$div>가 포함되어 있음.  
    - logo192.png : PWA(progressive wep app)용 아이콘.  
    - logo512.png : PWA(progressive wep app)용 아이콘.  
    - manifest.json: PWA 관련 설정 파일.  
    - robots.txt : 검색 엔진 크롤러의 접근을 제어하는 파일  
- src : React 앱의 주요 코드가 위치하는 폴더  
    - APP.css : App.js에 적용되는 스타일  
    - App.js : 메인 컴포넌트  
    - App.test.js : jest를 사용한 기본 테스트 파일  
    - index.js : react 앱의 진입점(entry point) - ReactDom.createRoot를 사용하며 App.js를 렌더링함.  
    - logo.svg : 기본 로고 이미지.  
    - reportWebVitals.js : 성능 측정 관련 코드(선택 사항)  
    - setupTests.js : 테스트 환경 설정 파일  
- gitignore : Git에 추가하지 않을 파일 목록을 정의  
- package-lock.json: 설치된 패키지의 정확한 버전이 기록된 파일.  
- package.json : 프로젝트의 의존성 목록과 실행 스크립트가 포함된 파일  
- README.md : 프로젝트 설명 문서  

- src/  
    - react 프로젝트의 주요 코드가 위치하는 디렉토리  
    - 개발함변서 대부분의 작업이 이루어지는 곳
- src/App.js  
    - 메인 component 로 필요한 sub component를 모아서 관리  
    - 출력을 위해서 index.js로 전달  
- src/App.css  
    - app.js에 적용되는 스타일을 정의하는 스타일 파일  
- src/index.js  
    - react 앱의 진입 점(entry point)으로 최종 렌더링의 되는 곳  
    - reactDom.createRoot를 사용하며 App.js를 렌더링  
- src/index.css  
    - 전역 스타일을 정의하는 스타일 파일  
# 2025.03.13 1주차

### 깃허브 와 vscode 연동  
##### 비쥬얼스튜디오 코드에서 터미널을 통한 깃허브 연동방법을 배움.    

### Node.js의 개발과정  
- 2009년 발표된 node.js를 개발한 라이언 달은 물리학을 전공했으나 개발에 흥미를 느껴 프리랜서 개발자로 일하던 개발자였음.  

- 아파치서버는 요청을 처리할 때 블로킹 방식으로 동작 한다는 문제가 있었고 이를 해결하기 위해 비둘기 방식의 서버가 필요하다고 판단하고 개발을시작함.  

- 개발을시작할 때는 파이썬을 사용했지만 자바스크립트의 비둘기 특성이 서버 개발에 더 적합하다고 판단해 자바스크립트를 방향으로 전환함  

- 당시 크롬이 가장 빠른 브라우저로 주목받고 있었고, 그 핵심인 v8 엔진을 이용  

### node.js가 인기를 끄는 이유 ??  
 - 빠른 성능
 - 자바스크립트만으로 풀스택 개발
 - 활발한생태계
 - 실시간 애플리케이션에 강함
 - 마이크로서비스 및 서버리스 환경과의 조화로운 변동  

- deno의 등장으로 node의 경쟁자로 떠올랐지만 node의 생태계가 훨씬 크고 안정적  
es 모듈 지원 강화 , 클라우드 서버리스 환경 확대 

###  react의 진화  
- 2024년 12월 19.0.0 버전이 공개되면서 다시 한번 많은 변화를 가져오고 있음   
- react의 주 버전은 2,3년에 한번씩 부 버전은 1년에 수차례 업그레이드되고 있음.  
- react는 이제 front end 개발자의 필수 과목이 됨.  

### react 개발환경 구축  
- 이전에는 별도로 설치해야 했기 때문에 인터넷의 오래된 자료를 보면 설치 방법이 나와있음.  
- node.js 0.6.3 버전부터 npm이 포함
